'use client';

import { useState, useEffect } from 'react';
import { useGameStore } from '@/store/gameStore';
import { MINION_ROLES, type QuestPhase } from '@/types/game';
import { Panel, Button, Input } from './Panel';
import { getRandomEvent } from '@/lib/questSimulation';

const PHASE_LABELS: Record<QuestPhase, string> = {
  departure: 'Departing...',
  travel: 'Traveling...',
  work: 'Working...',
  event: 'Event!',
  resolution: 'Resolving...',
  return: 'Returning...',
  complete: 'Complete!',
};

const PHASE_COLORS: Record<QuestPhase, string> = {
  departure: 'bg-blue-500',
  travel: 'bg-cyan-500',
  work: 'bg-amber-500',
  event: 'bg-purple-500',
  resolution: 'bg-green-500',
  return: 'bg-teal-500',
  complete: 'bg-emerald-500',
};

// Simulated quest progression
function useQuestSimulation(questId: string | null) {
  const updateQuestPhase = useGameStore((state) => state.updateQuestPhase);
  const updateQuestProgress = useGameStore((state) => state.updateQuestProgress);
  const addQuestEvent = useGameStore((state) => state.addQuestEvent);
  const completeQuest = useGameStore((state) => state.completeQuest);
  const createArtifact = useGameStore((state) => state.createArtifact);
  const createPostcard = useGameStore((state) => state.createPostcard);
  const quests = useGameStore((state) => state.quests);
  const updateMinionState = useGameStore((state) => state.updateMinionState);

  const quest = quests.find((q) => q.id === questId);

  useEffect(() => {
    if (!quest || quest.phase === 'complete') return;

    const phases: QuestPhase[] = ['departure', 'travel', 'work', 'event', 'resolution', 'return', 'complete'];
    const currentPhaseIndex = phases.indexOf(quest.phase);

    // Progress within current phase
    const progressInterval = setInterval(() => {
      if (quest.progress < 100) {
        updateQuestProgress(quest.id, quest.progress + Math.random() * 5 + 2);
      }
    }, 500);

    // Phase transition
    const phaseTimeout = setTimeout(() => {
      if (quest.progress >= 100 && currentPhaseIndex < phases.length - 1) {
        const nextPhase = phases[currentPhaseIndex + 1];

        // Update minion state based on phase
        if (nextPhase === 'work') {
          updateMinionState(quest.minionId, 'working');
        } else if (nextPhase === 'return') {
          updateMinionState(quest.minionId, 'returning');
        }

        // Random events
        if (nextPhase === 'event' && Math.random() > 0.3) {
          const eventTypes: ('flavor' | 'modifier' | 'social')[] = ['flavor', 'modifier', 'social'];
          const weights = [0.6, 0.25, 0.15]; // Flavor is most common
          const random = Math.random();
          let cumulative = 0;
          let selectedType: 'flavor' | 'modifier' | 'social' = 'flavor';
          for (let i = 0; i < weights.length; i++) {
            cumulative += weights[i];
            if (random < cumulative) {
              selectedType = eventTypes[i];
              break;
            }
          }
          addQuestEvent(quest.id, selectedType, getRandomEvent(selectedType));
        }

        if (nextPhase === 'complete') {
          // Create artifact
          const artifact = createArtifact(
            `Scroll of ${quest.title}`,
            'scroll',
            `Knowledge gathered from the quest: ${quest.title}`,
            `// Result of quest: ${quest.title}\n// Generated by ${quest.minionId}\n\nconst result = {\n  success: true,\n  data: "Quest completed successfully"\n};`,
            quest.id,
            quest.minionId,
            ['quest-result']
          );

          // Create postcard
          createPostcard(
            quest.id,
            quest.minionId,
            `Your minion ventured forth on a quest: "${quest.title}". Through determination and skill, they returned victorious, bearing the fruits of their labor.`,
            'Quest completed successfully!',
            [artifact.id]
          );

          completeQuest(quest.id);
        } else {
          updateQuestPhase(quest.id, nextPhase);
          updateQuestProgress(quest.id, 0);
        }
      }
    }, 3000 + Math.random() * 2000);

    return () => {
      clearInterval(progressInterval);
      clearTimeout(phaseTimeout);
    };
  }, [quest?.id, quest?.phase, quest?.progress]);
}

export function QuestPanel() {
  const minions = useGameStore((state) => state.minions);
  const quests = useGameStore((state) => state.quests);
  const activeQuestId = useGameStore((state) => state.activeQuestId);
  const selectedMinionId = useGameStore((state) => state.selectedMinionId);
  const createQuest = useGameStore((state) => state.createQuest);

  const [isCreating, setIsCreating] = useState(false);
  const [questTitle, setQuestTitle] = useState('');
  const [questDescription, setQuestDescription] = useState('');

  // Run quest simulation
  useQuestSimulation(activeQuestId);

  const activeQuest = quests.find((q) => q.id === activeQuestId);
  const selectedMinion = minions.find((m) => m.id === selectedMinionId);
  const availableMinions = minions.filter((m) => m.state === 'idle');

  const handleCreateQuest = () => {
    if (!questTitle.trim() || !selectedMinionId) return;
    createQuest(questTitle.trim(), questDescription.trim(), selectedMinionId);
    setQuestTitle('');
    setQuestDescription('');
    setIsCreating(false);
  };

  return (
    <Panel title="Quests" className="w-80">
      {activeQuest ? (
        <div className="space-y-4">
          {/* Active quest view */}
          <div className="space-y-2">
            <h3 className="font-medium text-white text-lg">{activeQuest.title}</h3>
            {activeQuest.description && (
              <p className="text-sm text-gray-400">{activeQuest.description}</p>
            )}
          </div>

          {/* Phase indicator */}
          <div className="space-y-2">
            <div className="flex items-center justify-between text-sm">
              <span className={`px-2 py-1 rounded-full text-white ${PHASE_COLORS[activeQuest.phase]}`}>
                {PHASE_LABELS[activeQuest.phase]}
              </span>
              <span className="text-gray-400">{Math.round(activeQuest.progress)}%</span>
            </div>
            <div className="h-2 bg-gray-700 rounded-full overflow-hidden">
              <div
                className={`h-full transition-all duration-300 ${PHASE_COLORS[activeQuest.phase]}`}
                style={{ width: `${activeQuest.progress}%` }}
              />
            </div>
          </div>

          {/* Events log */}
          {activeQuest.events.length > 0 && (
            <div className="space-y-2">
              <h4 className="text-sm font-medium text-gray-300">Events</h4>
              <div className="space-y-1 max-h-32 overflow-y-auto">
                {activeQuest.events.map((event) => (
                  <div
                    key={event.id}
                    className={`text-xs p-2 rounded ${
                      event.type === 'flavor'
                        ? 'bg-gray-800 text-gray-400'
                        : event.type === 'modifier'
                        ? 'bg-purple-900/30 text-purple-300'
                        : 'bg-blue-900/30 text-blue-300'
                    }`}
                  >
                    {event.text}
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      ) : isCreating ? (
        <div className="space-y-4">
          <Input
            label="Quest Title"
            value={questTitle}
            onChange={setQuestTitle}
            placeholder="e.g., Research API patterns"
          />
          <Input
            label="Description"
            value={questDescription}
            onChange={setQuestDescription}
            placeholder="What should the minion accomplish?"
            multiline
          />

          {selectedMinion ? (
            <div className="p-3 bg-gray-800 rounded-lg">
              <div className="flex items-center gap-2">
                <div
                  className="w-6 h-6 rounded-full"
                  style={{ backgroundColor: MINION_ROLES[selectedMinion.role].color }}
                />
                <span className="text-white">{selectedMinion.name}</span>
                <span className="text-gray-500 text-sm">will be dispatched</span>
              </div>
            </div>
          ) : (
            <p className="text-amber-500 text-sm">Select an idle minion first</p>
          )}

          <div className="flex gap-2">
            <Button variant="secondary" onClick={() => setIsCreating(false)} className="flex-1">
              Cancel
            </Button>
            <Button
              onClick={handleCreateQuest}
              disabled={!questTitle.trim() || !selectedMinion || selectedMinion.state !== 'idle'}
              className="flex-1"
            >
              Dispatch
            </Button>
          </div>
        </div>
      ) : (
        <div className="space-y-4">
          {/* Recent quests */}
          <div className="space-y-2 max-h-40 overflow-y-auto">
            {quests.length === 0 ? (
              <p className="text-gray-500 text-sm text-center py-4">
                No quests yet. Create your first!
              </p>
            ) : (
              quests
                .slice()
                .reverse()
                .slice(0, 5)
                .map((quest) => (
                  <div
                    key={quest.id}
                    className="p-3 bg-gray-800/50 rounded-lg border border-gray-700"
                  >
                    <div className="flex items-center justify-between">
                      <span className="text-white font-medium truncate">{quest.title}</span>
                      <span
                        className={`text-xs px-2 py-0.5 rounded-full ${
                          quest.phase === 'complete'
                            ? 'bg-emerald-500/20 text-emerald-400'
                            : 'bg-amber-500/20 text-amber-400'
                        }`}
                      >
                        {quest.phase === 'complete' ? 'Done' : 'Active'}
                      </span>
                    </div>
                  </div>
                ))
            )}
          </div>

          <Button
            onClick={() => setIsCreating(true)}
            disabled={availableMinions.length === 0}
            className="w-full"
          >
            {availableMinions.length === 0 ? 'No idle minions' : '+ Create Quest'}
          </Button>
        </div>
      )}
    </Panel>
  );
}
